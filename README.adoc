= NgRx Workshop

These are notes and code snippets from the NgRx-part of the Udemy Workshop https://www.udemy.com/the-complete-guide-to-angular-2[The complete guide to Angular], which is very much recommended. My notes to the rest of the topics from the guide can be found https://github.com/msg-DAVID-GmbH/AngularWorkshop[here].

== NgRx

* additional package
* alternative to storing state in an Angular application (either via services or NgRx)
* maintaining state in complex applications can become burdensome
* using _Subject_ in services = good thing because making sure that statechange only in this service + notification to rest of application

== Redux-like pattern
* like in React: only one central *Store* in application
* changing state through *Actions* that gets send to *Reducers*
* state-change immutable: old state doesn't get overwritten but archived

== Creating a Reducer
* reducers ad a new state
* parameters will be passed in function automatically by NgRx
* reducer-function will be triggered whenever an action is dispatched
* arguments of reducer-function:
1. State before the function is entered. If no state present, initial state can be determined. The spread-operator "..." means "take the old state"
1. action that overrides the specified part of the old state
* so basically the following says "take the old state and override _beverage_ with the payload from the action"

*my.reducers.ts*:

[source, javascript]
----
import * as MyActions from './my.actions';
import {Beverage} from './beverage';

const initialState = {
  beverage: new Beverage('Club Mate', 1)
};

export function beverageReducer(state = initialState, action: MyActions.AddBeverage) {

  switch (action.type) {
    case MyActions.ADD_BEVERAGE:
      return {
        ...state,
        beverage: action.payload
      };
    default:
      return state;
  }
}
----

*my.actions.ts*:

[source,javascript]
----
import {Action} from '@ngrx/store';
import {Beverage} from './beverage';

export const ADD_BEVERAGE = 'ADD_BEVERAGE';

export class AddBeverage implements Action {

  constructor(public payload: Beverage) {
  }

  readonly type = ADD_BEVERAGE;
}

export type MyActions = AddBeverage;
----

*app.module.ts*:

[source,javascript]
----
imports: [
  ...
  StoreModule.forRoot({beverageReducers: beverageReducer})
]
----

== Getting state & Dispatch Actions

* in constructor: global state has to be defined as JSON-object
* getting state: this.store.select
* dispatching actions: this.store.dispatch

[source,javascript]
----
export class AppComponent {

  valueFromStore: Beverage;

  constructor(private store: Store<Beverage>) {
  }

  onInputNewValue(form: NgForm) {

    const beverage = new Beverage(form.value.name, form.value.price);

    console.log('Writing to store:');
    console.log(beverage);

    this.store.dispatch(new MyActions.AddBeverage(beverage));

    console.log('Reading from store ...');

    this.store.select('beverageReducers').subscribe(stateObject => {
      this.valueFromStore = stateObject.beverage;
    });

  }
----

== Enhance Readability by using Interfaces for the State

_my.reducers.ts_:

[source,javascript]
----
export interface AppState {
  beverageModule: State;
}

export interface State {
  beverages: Beverage[];
  totalPrice: number;
}

const initialState: State = {
  beverages: [new Beverage('Club Mate', 0)],
  totalPrice: 0
};
----

used in _app.component.ts_:
[source,javascript]
----
constructor(private store: Store<fromBeverageModule.AppState>) {}
----

(instead of having to copy the specific state like this previous version (pretty simple state, but imagine it gets more complicated)):

[source,javascript]
----
constructor(private store: Store<Beverage>) {}
----

== Always work on copy of state
* when working with NgRx, past states must not be changed
* instead, create copy of it and work on thi s copy
* example: in reducer when removing a beverage, *don't* change a past state this way:

[source,javascript]
----
const beverages = state.beverages; // DON`T DO THAT!
beverages.splice(action.payload, 1);
----

* instead, create a copy of the past state to work on:

[source,javascript]
----
const beverages = [...state.beverages]; // get old beverages in an immutable way
beverages.splice(action.payload, 1);
----

* uses the https://basarat.gitbooks.io/typescript/docs/spread-operator.html[spread-operator] which spreads the content of an array
* additionally, the spread contents are framed by an array which makes it the same datatype as past state 

* also works for objects:

[source,javascript]
----
const oldStuff = {...state.stuff[index]};
----

== Further reading
* https://blog.angular-university.io/angular-2-redux-ngrx-rxjs/[Angular Service Layers: Redux, RxJs and Ngrx Store - When to Use a Store and why]
** stores not viewed by their creators as a one-size-fits-all-solution: "You’ll know when you need Flux. If you aren’t sure if you need it, you don’t need it."
